# 装饰器的优势并不在于它提供了动态修改函数的能力，而在于它把影响函数的装饰行为移到了函数头部，降低了代码的阅读与理解成本。
# 把修改函数的调用提前到了函数定义处，而这一点儿位置上的小变化，重塑了读者理解代码的整个过程。


'''
比如，当人们读到下面的函数定义语句时，马上就能明白：“哦，原来这个视图函数需要登录才能访问。“

@login_requried
def view_function(request):
    ...
'''


'''
装饰器特别适合用来实现以下功能。

（1） 运行时校验：在执行阶段进行特定校验，当校验通不过时终止执行。
· 适合原因：装饰器可以方便地在函数执行前介入，并且可以读取所有参数辅助校验。
· 代表样例：Django框架中的用户登录态校验装饰器@login_required。

（2） 注入额外参数：在函数被调用时自动注入额外的调用参数。
· 适合原因：装饰器的位置在函数头部，非常靠近参数被定义的位置，关联性强。
· 代表样例：unittest.mock模块的装饰器@patch。

（3） 缓存执行结果：通过调用参数等输入信息，直接缓存函数执行结果。
· 适合原因：添加缓存不需要侵入函数内部逻辑，并且功能非常独立和通用。
· 代表样例：functools模块的缓存装饰器@lru_cache。

（4） 注册函数：将被装饰函数注册为某个外部流程的一部分。
· 适合原因：在定义函数时可以直接完成注册，关联性强。
· 代表样例：Flask框架的路由注册装饰器@app.route。

（5）替换为复杂对象：将原函数（方法）替换为更复杂的对象，比如类实例或特殊的描述符对象（见12.1.3节）。
· 适合原因：在执行替换操作时，装饰器语法天然比foo = staticmethod(foo)的写法要直观得多。
· 代表样例：静态类方法装饰器@staticmethod。
'''

'''
在设计新的装饰器时，你可以先参考上面的常见装饰器功能列表，琢磨琢磨自己的设计是否能很好地发挥装饰器的优势。
切勿滥用装饰器技术，设计出一些天马行空但难以理解的API。
吸取前人经验，同时在设计上保持克制，才能写出更好用的装饰器。
'''
