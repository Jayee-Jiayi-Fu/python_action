
装饰器是Python为我们提供的一颗语法糖，它和“装饰器模式”没有任何关系。

任何可调用对象都可以当作装饰器来使用，因此，除了最常见的用嵌套函数来实现装饰器外，也可以用类来实现装饰器。

在装饰器包装原始函数的过程中，会产生“元数据丢失”副作用，可以通过functools.wraps()来解决这个问题。

用类实现的装饰器分为两种：“函数替换”与“实例替换”。后者可以有效地实现状态管理、追加行为功能。在实现有参数“实例替换”装饰器时，你需要定义一个额外的函数来配合装饰器类。

在编写装饰器时，第三方工具包wrapt非常有用，借助它能写出更扁平的装饰器，也更容易兼容装饰函数与类方法两种场景。


以下是本章要点知识总结。
（1）基础与技巧
· 装饰器最常见的实现方式，是利用闭包原理通过多层嵌套函数实现
· 在实现装饰器时，请记得使用wraps()更新包装函数的元数据
· wraps()不光可以保留元数据，还能保留包装函数的额外属性
· 利用仅限关键字参数，可以很方便地实现可选参数的装饰器

（2）使用类来实现装饰器· 只要是可调用的对象，都可以用作装饰器
· 实现了__call__方法的类实例可调用· 基于类的装饰器分为两种：“函数替换”与“实例替换”
· “函数替换”装饰器与普通装饰器没什么区别，只是嵌套层级更少
· 通过类来实现“实例替换”装饰器，在管理状态和追加行为上有天然的优势
· 混合使用类和函数来实现装饰器，可以灵活满足各种场景


（3）使用wrapt模块
· 使用wrapt模块可以方便地让装饰器同时兼容函数和类方法
· 使用wrapt模块可以帮你写出结构更扁平的装饰器代码

（4）装饰器设计技巧
· 装饰器将包装调用提前到了函数被定义的位置，它的大部分优点也源于此
· 在编写装饰器时，请考虑你的设计是否能很好发挥装饰器的优势
· 在某些场景下，类装饰器可以替代元类，并且代码更简单
· 装饰器和装饰器模式截然不同，不要弄混它们
· 装饰器里应该只有一层浅浅的包装代码，要把核心逻辑放在其他函数与类中