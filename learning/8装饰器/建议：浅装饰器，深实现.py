'''
在编写装饰器时，人们很容易产生这样的想法：“我的装饰器要实现某个功能，所以我要把所有逻辑都放在装饰器里实现。”
抱着这样的想法去写代码，很容易写出异常复杂的装饰器代码。
在编写了许多装饰器后，一种更好的代码组织思路，那就是：浅装饰器，深实现。
'''


'''
流行的第三方命令行工具包Click里大量使用了装饰器。
Click的所有装饰器都在一个不到400行代码的decorators.py文件中，里面的大部分装饰器的代码不超过10行，
如@click.command装饰器源码,
它所做的，只是简单地把被装饰函数替换为Command实例，而所有核心逻辑都在Command实例中。
'''


def command(name=None, cls=None, **attrs):
    if cls is None:
        cls = Command

    def decorator(f):
        cmd = _make_command(f, name, attrs, cls)
        cmd.__doc__ = f.__doc__
        return cmd

    return decorator

    '''
    这样的装饰器很浅，只做一些微小的工作，但这样的代码扩展性其实更强。
    因为归根结底，装饰器其实只是一类特殊的API，一种提供服务的方式。
    比起把所有核心逻辑都放在装饰器内，不如让装饰器里只有一层浅浅的包装层，而把更多的实现细节放在其他函数或类中。
    这样做之后，假如你未来需要为模块增加装饰器以外的其他API，比如上下文管理器，就会发现自己之前写的大部分核心代码仍然可以复用，因为它们并没有和装饰器耦合。
    ''''
